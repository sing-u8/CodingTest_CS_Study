# 🌐 프로그래머스: 네트워크 (DFS/BFS) 문제 풀이 가이드

본 문서는 그래프 이론의 핵심인 **연결 요소(Connected Component)**를 찾는 세 가지 접근 방식(DFS, BFS, OOP)에 대해 상세히 설명합니다.

---

## 📑 목차
1. [방법 1: DFS (깊이 우선 탐색)](#1-방법-1-dfs-깊이-우선-탐색)
   - [근본 원리: 땅따먹기 비유](#1-근본-원리-땅따먹기-비유)
   - [코드 상세 분석](#2-코드-상세-분석)
   - [동작 과정 시뮬레이션](#3-동작-과정-시뮬레이션)
2. [방법 2: BFS (너비 우선 탐색)](#2-방법-2-bfs-너비-우선-탐색)
   - [동작 원리: 전염병 확산 비유](#동작-원리-전염병-확산-비유)
   - [Java 구현 코드](#java-구현-코드)
3. [방법 3: OOP 스타일 (객체지향 설계)](#3-방법-3-oop-스타일-객체지향-설계)
   - [객체지향적 접근의 핵심](#객체지향적-관점의-핵심-포인트)
   - [Java 구현 코드](#java-객체지향oop-스타일-풀이)
4. [💡 종합 비교 및 팁](#-종합-비교-및-팁)

---

## 1. 방법 1: DFS (깊이 우선 탐색)

### 1) 근본 원리: 땅따먹기 비유
이 문제를 직관적으로 이해하려면 **"지도에서 섬의 개수 세기"**라고 생각하면 가장 쉽습니다.

*   **컴퓨터**: 땅(지역)
*   **연결**: 다리(Bridge)
*   **네트워크**: 다리로 연결된 땅들의 덩어리(하나의 섬)
*   **`visit` 배열**: 깃발 꽂기 (이미 밟은 땅 표시)

**전략:**
1.  **전체 탐색**: 1번 땅부터 n번 땅까지 순서대로 훑어봅니다.
2.  **새로운 섬 발견**: 만약 어떤 땅에 도착했는데 깃발이 없다면(`!visit[i]`), 그곳은 **새로운 섬(네트워크)의 시작점**입니다. (이때 `answer++`)
3.  **영역 확장 (DFS)**: 그 땅에서 시작해서 다리로 연결된 모든 땅을 찾아다니며 깃발을 꽂습니다. 연결된 곳이 없을 때까지 끝까지 들어갑니다.
4.  **복귀 및 반복**: 더 이상 갈 곳이 없으면 돌아옵니다. 이미 깃발이 꽂힌 땅은 무시하고 다음 땅을 확인합니다.

### 2) 코드 상세 분석

#### **A. 준비 단계 (`solution` 함수 초반)**
```java
int answer = 0; // 네트워크(섬)의 개수
boolean[] visit = new boolean[n]; // 방문 체크 배열 (깃발)
```
*   **핵심**: 그래프 탐색에서 **무한 루프**와 **중복 카운팅**을 방지하기 위한 메모장입니다.

#### **B. 전체 스캔 루프 (`solution` 함수 중반)**
```java
for (int i = 0; i < n; i++) {
    if(!visit[i]) {           // "아직 방문하지 않은 컴퓨터"라면? -> 새로운 네트워크 발견!
        dfs(n, computers, i, visit); // 그 네트워크에 속한 모든 컴퓨터를 찾아 깃발 꽂고 와라!
        answer++;             // 네트워크 하나 찾았으니 카운트 +1
    }
}
```
*   `if(!visit[i])` 조건이 이 알고리즘의 **심장**입니다. 이미 확인된 그룹은 건너뜁니다.

#### **C. 깊이 우선 탐색 (`dfs` 함수)**
```java
public void dfs(int n, int[][] computers, int idx, boolean[] visit) {
    visit[idx] = true; // 1. 현재 컴퓨터에 깃발 꽂기

    for (int i = 0; i < n; i++) {
        // (1) 자기 자신이 아니고 (2) 방문 안 했고 (3) 연결되어 있다면
        if (idx != i && visit[i] == false && computers[idx][i] == 1) {
            dfs(n, computers, i, visit); // 3. 그 컴퓨터로 이동 (재귀)
        }
    }
}
```
*   **재귀(Recursion)의 역할**: "꼬리에 꼬리를 물고" 끝까지 탐색하여 연결된 모든 노드를 `true`로 만듭니다.

### 3) 동작 과정 시뮬레이션 (입출력 예 #1)
*   **입력**: `n=3`, `[[1, 1, 0], [1, 1, 0], [0, 0, 1]]`

1.  **Step 1 (i=0)**: `visit[0]`이 `false`이므로 새로운 네트워크 발견. `dfs(0)` 실행.
    *   0번 방문 처리 -> 연결된 1번 방문 처리 -> `dfs(1)` 종료 -> `dfs(0)` 종료.
    *   `answer = 1`, `visit = [T, T, F]`
2.  **Step 2 (i=1)**: `visit[1]`이 `true`이므로 패스.
3.  **Step 3 (i=2)**: `visit[2]`가 `false`이므로 새로운 네트워크 발견. `dfs(2)` 실행.
    *   2번 방문 처리 -> 연결된 곳 없음 -> 종료.
    *   `answer = 2`, `visit = [T, T, T]`
4.  **최종**: `answer = 2` 반환.

---

## 2. 방법 2: BFS (너비 우선 탐색)

DFS가 **"한 놈만 팬다"**는 방식이라면, BFS는 **"내 주위부터 챙긴다"**는 방식입니다.

### 동작 원리: 전염병 확산 비유
1.  **큐(Queue) 준비**: 감염 대기 명단.
2.  **발생**: 첫 번째 환자(`start`)를 대기 명단에 넣고 방문 처리.
3.  **조사**: 대기 명단에서 한 명을 꺼내 연결된 모든 사람을 확인합니다.
4.  **전파**: 연결되어 있고 아직 감염 안 된 사람이 있다면, **즉시 감염 처리**하고 명단에 넣습니다.
5.  **반복**: 명단이 빌 때까지 반복하면 연결된 모든 그룹이 처리됩니다.

### Java 구현 코드
```java
import java.util.*;

class Solution {
    public int solution(int n, int[][] computers) {
        int answer = 0;
        boolean[] visit = new boolean[n];

        for (int i = 0; i < n; i++) {
            if (!visit[i]) {
                bfs(n, computers, i, visit);
                answer++;
            }
        }
        return answer;
    }

    public void bfs(int n, int[][] computers, int start, boolean[] visit) {
        Queue<Integer> q = new LinkedList<>();
        q.offer(start);
        visit[start] = true;

        while (!q.isEmpty()) {
            int current = q.poll();
            for (int i = 0; i < n; i++) {
                if (computers[current][i] == 1 && !visit[i]) {
                    visit[i] = true;
                    q.offer(i);
                }
            }
        }
    }
}
```

---

## 3. 방법 3: OOP 스타일 (객체지향 설계)

객체지향의 핵심은 **"객체들이 서로 메시지를 주고받으며 협력하게 만드는 것"**입니다.

### 객체지향적 관점의 핵심 포인트
1.  **캡슐화 (Encapsulation)**: `visit` 상태가 `Computer` 객체 내부(`isVisited`)로 숨었습니다.
2.  **메시지 패싱 (Message Passing)**: 함수가 배열을 찌르는 게 아니라, A가 B에게 "너도 전파해"라고 명령합니다.
3.  **관계 중심**: 2차원 배열 대신 `neighbors` 리스트로 직접적인 관계를 관리합니다.

### Java 객체지향(OOP) 스타일 풀이
```java
import java.util.*;

class Solution {
    static class Computer {
        private int idx;
        private boolean isVisited;
        private List<Computer> neighbors = new ArrayList<>();

        public Computer(int idx) { this.idx = idx; }
        public void addNeighbor(Computer other) { this.neighbors.add(other); }
        public boolean isVisited() { return this.isVisited; }

        public void spreadNetwork() {
            if (this.isVisited) return;
            this.isVisited = true;
            for (Computer neighbor : neighbors) {
                neighbor.spreadNetwork();
            }
        }
    }

    public int solution(int n, int[][] computers) {
        List<Computer> computerList = new ArrayList<>();
        for (int i = 0; i < n; i++) computerList.add(new Computer(i));

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i != j && computers[i][j] == 1) {
                    computerList.get(i).addNeighbor(computerList.get(j));
                }
            }
        }

        int count = 0;
        for (Computer comp : computerList) {
            if (!comp.isVisited()) {
                count++;
                comp.spreadNetwork();
            }
        }
        return count;
    }
}
```

---

## 💡 종합 비교 및 팁

| 구분 | DFS (깊이 우선) | BFS (너비 우선) | OOP 스타일 |
| :--- | :--- | :--- | :--- |
| **구현 도구** | 재귀 함수 | Queue 자료구조 | 클래스 & 객체 |
| **특징** | 코드가 간결함 | 최단 거리 탐색에 유리 | 유지보수 및 확장성 우수 |
| **적합성** | 알고리즘 문제 풀이 | 알고리즘 문제 풀이 | 실무 및 대규모 시스템 |

### 멘토의 조언
*   **코딩 테스트**: 시간과 메모리 효율이 좋은 **DFS/BFS** 방식을 추천합니다.
*   **면접/실무**: "실제 시스템이라면 확장성을 고려해 **OOP**로 설계했을 것"이라고 답변하면 좋은 인상을 남길 수 있습니다.
*   **시간 복잡도**: 세 방식 모두 $O(N^2)$로 동일합니다. (컴퓨터 수가 200대 이하이므로 충분히 통과 가능)

---
*작성된 코드는 군더더기 없는 정석 풀이입니다. 이 로직을 잘 익혀두시면 '바이러스 확산'이나 '영역 넓이 구하기' 문제도 쉽게 해결할 수 있습니다! 👍*
