이 문제는 **"가장 짧은 변환 과정"**을 찾는 것이 핵심입니다. 이전 문제(게임 맵 최단거리)와 마찬가지로, **최단 경로(Minimum Steps)**를 묻는 문제는 **BFS(너비 우선 탐색)**를 사용하는 것이 가장 적합합니다.

단어들을 '노드(Node)'로, 한 글자만 바꿔서 이동할 수 있는 관계를 '간선(Edge)'으로 생각하면, 이 문제는 그래프의 최단 거리 문제와 똑같아집니다.

## 1. 문제 해결 전략 (논리적 사고 흐름)

1. **그래프 모델링**:
* `begin` 단어에서 시작합니다.
* `words` 리스트에 있는 단어 중, 현재 단어와 **알파벳이 딱 하나만 다른 단어**로 이동할 수 있습니다.


2. **탐색 방식 (BFS)**:
* 시작 단어(`hit`)에서 한 번에 갈 수 있는 단어(`hot`)를 모두 찾습니다. (1단계)
* 그다음 `hot`에서 갈 수 있는 단어들(`dot`, `lot`)을 찾습니다. (2단계)
* 이 과정을 반복하다가 `target` 단어(`cog`)를 만나는 순간, 그때의 단계 수가 **최소 단계**가 됩니다.


3. **필수 조건**:
* 한 번 방문한 단어는 다시 방문하지 않아야 합니다. (무한 루프 방지 및 최단 거리 보장) -> `visited` 배열 필요.
* 두 단어가 변환 가능한지 확인하는 함수가 필요합니다. (알파벳 차이가 1개인지 확인)



---

## 2. Java 코드 (BFS 풀이)

```java
import java.util.*;

class Solution {
    // 큐에 넣을 상태 클래스 (단어, 현재까지의 단계 수)
    class State {
        String word;
        int step;

        public State(String word, int step) {
            this.word = word;
            this.step = step;
        }
    }

    public int solution(String begin, String target, String[] words) {
        // 1. 예외 처리: target이 words 안에 없으면 변환 불가능하므로 0 반환
        boolean containsTarget = false;
        for (String w : words) {
            if (w.equals(target)) {
                containsTarget = true;
                break;
            }
        }
        if (!containsTarget) return 0;

        // 2. BFS 준비
        Queue<State> queue = new LinkedList<>();
        queue.offer(new State(begin, 0));
        
        // 방문 여부 체크 (words 배열의 인덱스 기준)
        boolean[] visited = new boolean[words.length];

        // 3. 탐색 시작
        while (!queue.isEmpty()) {
            State current = queue.poll();

            // 목표 단어 도달 시 단계 수 반환
            if (current.word.equals(target)) {
                return current.step;
            }

            // words 배열을 순회하며 다음으로 갈 수 있는 단어 찾기
            for (int i = 0; i < words.length; i++) {
                // 이미 방문한 단어는 패스
                if (visited[i]) {
                    continue;
                }

                // 현재 단어와 한 글자만 차이나는지 확인 (변환 가능 여부)
                if (canConvert(current.word, words[i])) {
                    visited[i] = true; // 방문 처리
                    queue.offer(new State(words[i], current.step + 1));
                }
            }
        }

        // 큐가 빌 때까지 target에 도달하지 못하면 0 반환
        return 0;
    }

    // 두 단어가 한 글자만 다른지 확인하는 헬퍼 함수
    private boolean canConvert(String w1, String w2) {
        int diffCount = 0;
        for (int i = 0; i < w1.length(); i++) {
            if (w1.charAt(i) != w2.charAt(i)) {
                diffCount++;
            }
        }
        // 차이가 딱 1개일 때만 true
        return diffCount == 1;
    }
}

```

---

## 3. 코드 상세 설명

1. **`State` 클래스**:
* BFS 큐에 단순히 단어(`String`)만 넣으면, 몇 단계만에 왔는지 알기 어렵습니다. 그래서 `(단어, 단계수)`를 묶어서 관리하기 위해 내부 클래스를 만들었습니다.


2. **`canConvert` 함수 (핵심 로직)**:
* 두 문자열을 비교해서 틀린 글자 수를 셉니다.
* `hit`와 `hot` -> `i`와 `o` 하나만 다름 -> `true`
* `hit`와 `dog` -> `h-d`, `i-o`, `t-g` 세 개 다름 -> `false`
* 이 함수가 `true`를 반환할 때만 큐에 넣습니다.


3. **`visited` 배열**:
* `words` 배열의 길이만큼 `boolean` 배열을 만듭니다.
* 만약 `hot`을 이미 거쳐갔다면, 나중에 다른 경로로 다시 `hot`에 와도 큐에 넣지 않습니다. 이는 최단 거리를 구하기 위함이자 사이클(뺑뺑이)을 막기 위함입니다.


4. **`target` 존재 확인**:
* 문제 조건 중 "변환할 수 없는 경우 0 return"이 있습니다. 시작하자마자 `words`에 `target`이 있는지 확인하면 불필요한 연산을 줄일 수 있습니다. (사실 이 부분이 없어도 BFS는 큐가 비어서 0을 리턴하겠지만, 미리 거르는 것이 효율적입니다.)



## 4. 왜 DFS보다 BFS가 좋을까요?

* **DFS(깊이 우선 탐색)**로 풀면, 한 경로를 끝까지 파고듭니다. 예를 들어 `hit -> hot -> dot -> dog -> cog` (4단계)를 찾았더라도, 다른 경로 `hit -> ... -> cog`가 3단계일 수도 있습니다. 그래서 DFS는 모든 경로를 다 찾은 뒤 그중 최솟값을 비교해야 합니다.
* **BFS(너비 우선 탐색)**는 시작점에서 1단계인 단어들, 2단계인 단어들을 순차적으로 퍼져나가며 찾습니다. 따라서 **`target`을 발견하는 순간 그 경로가 무조건 최단 경로**입니다.


네, 아주 좋은 질문입니다! 이 부분이 가장 중요하면서도 추상적인 부분이라 처음에는 머릿속에 잘 그려지지 않을 수 있습니다.

"단어가 그래프가 된다"는 것이 무슨 뜻인지, 그리고 그 위에서 BFS가 어떻게 움직이는지 **시각적으로 아주 명확하게** 보여드리겠습니다.

---

## 5. 단어의 그래프화 (Modeling)

이전 문제(게임 맵)에서는 눈에 보이는 `격자(Grid)`가 있었지만, 이번 문제에서는 **눈에 보이지 않는 지도**를 상상해야 합니다.

* **노드 (Node, 정점):** 각각의 `단어` 그 자체입니다.
* **간선 (Edge, 연결선):** 두 단어가 **알파벳 하나만 다를 때**, 두 단어 사이에는 "길(다리)"이 놓여 있다고 봅니다.

**예시 데이터:**

* `begin`: **"hit"**
* `target`: **"cog"**
* `words`: `["hot", "dot", "dog", "lot", "log", "cog"]`

#### [이미지 1] 단어들 사이의 연결 관계 (지도 그리기)

먼저, 누가 누구랑 연결될 수 있는지 선을 그어 봅시다.

```text
      (시작)
      [hit]
        │ (i -> o 로 변경 가능)
        ▼
      [hot] ──────────────┐
        │                 │
    (h -> d)          (h -> l)
        │                 │
        ▼                 ▼
      [dot]             [lot]
        │                 │
    (t -> g)          (t -> g)
        │                 │
        ▼                 ▼
      [dog] ─────────── [log]
        │     (d <-> l)   │
        │                 │
        └───────┬─────────┘
                │
            (o -> c)
                │
                ▼
              [cog] (도착!)

```

* `hit`와 `hot`은 'i'와 'o' 차이 하나뿐이므로 연결됩니다.
* `hot`에서 `dot`(h->d)으로 갈 수도 있고, `lot`(h->l)으로 갈 수도 있습니다.
* `dog`와 `log`는 서로 연결되어 있고, 둘 다 `cog`로 갈 수 있습니다.

---

### 5.1. BFS 탐색 과정 (물결 퍼지듯 찾기)

BFS는 **시작점(`hit`)에서 돌을 던졌을 때 물결이 퍼져나가는 것**과 똑같습니다.

#### Step 0: 시작 (거리 0)

* 현재 위치: **`hit`**
* 큐 상태: `["hit"(0)]`

#### Step 1: 한 번 변환 (거리 1)

`hit`에서 연결된 선을 타고 갈 수 있는 모든 곳을 찾습니다.

* `hit` -> **`hot`** (가능)
* 큐 상태: `["hot"(1)]`
* 방문 체크: `hit`, `hot`

```text
(Start)
 [hit] 
   │
   ▼
 [hot]  <-- 현재 탐색 범위 (거리 1)

```

#### Step 2: 두 번 변환 (거리 2)

이제 큐에서 `hot`을 꺼내고, `hot`이랑 연결된 애들을 다 찾습니다.

* `hot` -> **`dot`**
* `hot` -> **`lot`**
* 큐 상태: `["dot"(2), "lot"(2)]`

```text
 [hit]
   │
 [hot]
   ├─── [dot]  <-- 현재 탐색 범위 (거리 2)
   └─── [lot]  <-- 현재 탐색 범위 (거리 2)

```

#### Step 3: 세 번 변환 (거리 3)

큐에서 `dot`과 `lot`을 순서대로 꺼내서 다음 갈 곳을 찾습니다.

* `dot` -> **`dog`**
* `lot` -> **`log`**
* 큐 상태: `["dog"(3), "log"(3)]`

```text
      ...
   ┌─── [dot] ─── [dog] <-- 현재 탐색 범위 (거리 3)
   └─── [lot] ─── [log] <-- 현재 탐색 범위 (거리 3)

```

#### Step 4: 네 번 변환 (거리 4) - 정답 발견!

큐에서 `dog`를 꺼내봅니다.

* `dog` -> **`cog`** (오! 타겟이다!)

또는 큐에서 `log`를 꺼내봅니다.

* `log` -> **`cog`** (오! 타겟이다!)

어느 쪽이든 `cog`를 만나는 순간 탐색을 멈추고 거리를 반환합니다.

```text
              ...
      ┌─── [dog] ─── [cog] !! 발견 !! (거리 4)
      └─── [log] ─── [cog]

```

---

### 5.2. 왜 이게 최단 거리인가요?

만약 DFS(깊이 우선 탐색)로 풀었다면, 운 나쁘게 `hit -> hot -> dot -> dog -> log -> lot -> ...` 처럼 뱅글뱅글 도는 경로를 먼저 선택할 수도 있습니다.

하지만 BFS는 위 그림처럼 **양파 껍질 까듯이** `거리 1`인 그룹을 다 보고, 없으면 `거리 2`인 그룹을 다 봅니다. 그렇기 때문에 **가장 먼저 `cog`를 만난 그 순간이 무조건 가장 짧은 경로(Level)**가 되는 것입니다.

### 요약

1. **맵 만들기**: 단어는 `노드`, 1글자 차이는 `길(간선)`이라고 생각하고 보이지 않는 지도를 머릿속에 그립니다.
2. **퍼져 나가기**: 시작 단어부터 연결된 단어들을 층층이(Layer by Layer) 탐색합니다.
3. **발견 즉시 종료**: 목표 단어가 나오는 순간, 그 층(Layer)의 깊이가 정답입니다.

이제 머릿속에 그림이 그려지시나요? 코드를 짤 때 이 그림을 떠올리며 `queue.offer`를 하는 것이 "다음 층으로 넘어간다"는 의미임을 기억하면 훨씬 쉬워질 거예요!