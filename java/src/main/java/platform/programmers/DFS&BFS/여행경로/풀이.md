```java

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
class Solution {
    List<String> list = new ArrayList<>();
	static String route = "";
	static boolean[] visit;
	
	private void dfs(String[][] tickets, String end, int cnt) {
		route += end + ",";
		
		if(cnt == tickets.length) {
			list.add(route); return;
		}
		
		for(int i = 0; i < tickets.length; i++) {
			String s = tickets[i][0], e = tickets[i][1];
			if(s.equals(end) && !visit[i]) {
				visit[i] = true;
				dfs(tickets, e, cnt + 1);
				visit[i] = false; route = route.substring(0, route.length()-4);
			}
		}
	}
	
	public String[] solution(String[][] tickets) {
		for(int i = 0; i < tickets.length; i++) {
			visit = new boolean[tickets.length];
			String start = tickets[i][0], end = tickets[i][1];
			
			if(start.equals("ICN")) {
				route = start + ","; visit[i] = true; 
				dfs(tickets, end, 1);
			}
		}
		
		Collections.sort(list);
		String[] answer = list.get(0).split(",");

		return answer;
	}
}

```


ì•ˆë…•í•˜ì„¸ìš”! **ì½”ë”© í…ŒìŠ¤íŠ¸ ë§ˆìŠ¤í„°**ì…ë‹ˆë‹¤.

ë³´ë‚´ì£¼ì‹  ë¬¸ì œì™€ ì‘ì„±í•˜ì‹  ì½”ë“œë¥¼ ì•„ì£¼ ê¼¼ê¼¼íˆ í™•ì¸í–ˆìŠµë‹ˆë‹¤. **"ì—¬í–‰ê²½ë¡œ"** ë¬¸ì œëŠ” ê·¸ë˜í”„ ì´ë¡  ì¤‘ **DFS(ê¹Šì´ ìš°ì„  íƒìƒ‰)** ë˜ëŠ” **ì˜¤ì¼ëŸ¬ ê²½ë¡œ(Eulerian Path)** ê°œë…ì„ í™œìš©í•˜ëŠ” ëŒ€í‘œì ì¸ ë¬¸ì œì…ë‹ˆë‹¤.

ì‘ì„±í•˜ì‹  ì½”ë“œëŠ” **ì™„ì „ íƒìƒ‰(Backtracking)** ë°©ì‹ì„ ì‚¬ìš©í•˜ì—¬ ëª¨ë“  ê°€ëŠ¥í•œ ê²½ë¡œë¥¼ ì°¾ì€ ë’¤ ì •ë ¬í•˜ëŠ” ë°©ì‹ì´êµ°ìš”. ë…¼ë¦¬ì ìœ¼ë¡œ ì •í™•í•˜ë©° ì •ë‹µì„ ë„ì¶œí•  ìˆ˜ ìˆëŠ” í›Œë¥­í•œ ì ‘ê·¼ì…ë‹ˆë‹¤.

ë‹¤ë§Œ, ëª‡ ê°€ì§€ **ìµœì í™” í¬ì¸íŠ¸**ì™€ ì´ ë¬¸ì œë¥¼ ë°”ë¼ë³´ëŠ” **ì™„ì „íˆ ë‹¤ë¥¸ ì‹œê°(ìŠ¤íƒ/ì¬ê·€ë¥¼ ì´ìš©í•œ ì˜¤ì¼ëŸ¬ ê²½ë¡œ)**ì„ ì†Œê°œí•´ ë“œë¦¬ê³ ì í•©ë‹ˆë‹¤. ì´ ë°©ë²•ë“¤ì„ ìµíˆì‹œë©´ íš¨ìœ¨ì„±ê³¼ ì½”ë“œì˜ ê°„ê²°í•¨ì„ ë™ì‹œì— ì¡ìœ¼ì‹¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

### ğŸ’¡ ì‚¬ìš©ì ì½”ë“œ ë¶„ì„ ë° í”¼ë“œë°±

ì‘ì„±í•˜ì‹  ì½”ë“œë„ í›Œë¥­í•˜ì§€ë§Œ, ì½”ë”© í…ŒìŠ¤íŠ¸ ê´€ì ì—ì„œ ëª‡ ê°€ì§€ ê°œì„ í•  ìˆ˜ ìˆëŠ” ë¶€ë¶„ì´ ìˆìŠµë‹ˆë‹¤.

1. **ë¬¸ìì—´ ì—°ì‚° ë¹„ìš©**: `route += end + ","`ì™€ `substring` ì—°ì‚°ì€ ë°˜ë³µë  ë•Œë§ˆë‹¤ ìƒˆë¡œìš´ ë¬¸ìì—´ ê°ì²´ë¥¼ ìƒì„±í•˜ë¯€ë¡œ ë©”ëª¨ë¦¬ì™€ ì‹œê°„ ì†Œëª¨ê°€ í½ë‹ˆë‹¤. `StringBuilder`ë‚˜ `List`ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ í›¨ì”¬ íš¨ìœ¨ì ì…ë‹ˆë‹¤.
2. **ì‚¬í›„ ì •ë ¬ (Post-sorting)**: ê°€ëŠ¥í•œ ëª¨ë“  ê²½ë¡œë¥¼ ë‹¤ êµ¬í•œ ë’¤(`list.add`) ë§ˆì§€ë§‰ì— `Collections.sort`ë¥¼ í•˜ê³  ìˆìŠµë‹ˆë‹¤. ë§Œì•½ í‹°ì¼“ì´ ë§ê³  ê²½ë¡œì˜ ìˆ˜ê°€ ë§¤ìš° ë§ë‹¤ë©´ ì‹œê°„ ì´ˆê³¼ê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. íƒìƒ‰ì„ ì‹œì‘í•˜ê¸° ì „ì— **ë„ì°©ì§€ë¥¼ ì•ŒíŒŒë²³ìˆœìœ¼ë¡œ ì •ë ¬**í•´ë‘ë©´, ê°€ì¥ ë¨¼ì € ì™„ì„±ëœ ê²½ë¡œê°€ ê³§ ì •ë‹µì´ ë˜ë¯€ë¡œ íƒìƒ‰ì„ ì¡°ê¸° ì¢…ë£Œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

### ğŸš€ ì¶”ì²œ í•´ê²° ì „ëµ

ì´ ë¬¸ì œëŠ” ë‘ ê°€ì§€ì˜ ì„¸ë ¨ëœ ë°©ë²•ìœ¼ë¡œ í•´ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

1. **ì „ëµ 1: ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ + ì •ë ¬ + DFS (ë°±íŠ¸ë˜í‚¹ ìµœì í™”)**
* ì‚¬ìš©ìë¶„ì˜ ì ‘ê·¼ë²•ì„ ê°œì„ í•œ í˜•íƒœì…ë‹ˆë‹¤.
* `Map<String, List<String>>`ì„ ë§Œë“¤ì–´ ê°„ì„ ì„ ê´€ë¦¬í•˜ê³ , ë„ì°©ì§€ ë¦¬ìŠ¤íŠ¸ë¥¼ ë¯¸ë¦¬ ì •ë ¬í•©ë‹ˆë‹¤.
* ê²½ë¡œê°€ ì™„ì„±ë˜ìë§ˆì íƒìƒ‰ì„ ë©ˆì¶¥ë‹ˆë‹¤.


2. **ì „ëµ 2: ê³„ì¸µì  ì ‘ê·¼ (Hierholzerâ€™s Algorithm ì‘ìš©)**
* **ê°€ì¥ ì¶”ì²œí•˜ëŠ” ë°©ë²•**ì…ë‹ˆë‹¤.
* ëª¨ë“  í‹°ì¼“ì„ ì†Œëª¨í•´ì•¼ í•œë‹¤ëŠ” ì (ì˜¤ì¼ëŸ¬ ê²½ë¡œ)ì„ ì´ìš©í•©ë‹ˆë‹¤.
* ê°ˆ ìˆ˜ ìˆëŠ” ê³³ê¹Œì§€ ê¹Šê²Œ ë“¤ì–´ê°„ í›„, ë” ì´ìƒ ê°ˆ ê³³ì´ ì—†ì„ ë•Œ í•´ë‹¹ ê³µí•­ì„ ê²½ë¡œì˜ 'ë§ˆì§€ë§‰'ìœ¼ë¡œ ì¶”ê°€í•˜ë©° ì—­ìˆœìœ¼ë¡œ ê²½ë¡œë¥¼ ì™„ì„±í•©ë‹ˆë‹¤.



---

### ğŸ’» ì†”ë£¨ì…˜ ì½”ë“œ

ì£¼ë¡œ ì‚¬ìš©í•˜ì‹œëŠ” **Java**ë¡œ ë‘ ê°€ì§€ ë°©ë²•ì„ ëª¨ë‘ ë³´ì—¬ë“œë¦¬ê³ , **C++, JavaScript, Rust** ì½”ë“œëŠ” ê°€ì¥ íš¨ìœ¨ì ì¸ 'ì „ëµ 2'ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì œê³µí•´ ë“œë¦¬ê² ìŠµë‹ˆë‹¤.

#### 1. Java: ì „ëµ 1 (DFS + ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ + ì„  ì •ë ¬)

ì´ ë°©ì‹ì€ ì§ê´€ì ì´ë©° ì‚¬ìš©ìë¶„ì˜ ê¸°ì¡´ ë¡œì§ê³¼ íë¦„ì´ ìœ ì‚¬í•©ë‹ˆë‹¤.

```java
import java.util.*;

class Solution {
    boolean[] visited;
    ArrayList<String> allRoute; 
    
    public String[] solution(String[][] tickets) {
        // 1. ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ ìƒì„± ì‹œ ìë™ ì •ë ¬ íš¨ê³¼ë¥¼ ìœ„í•´ ë‚´ìš©ë¬¼ë§Œ ì •ë ¬í•˜ê±°ë‚˜ PriorityQueue ì‚¬ìš© ê³ ë ¤
        // í•˜ì§€ë§Œ ì¸ë±ìŠ¤ ê¸°ë°˜ ë°©ë¬¸ ì²´í¬ë¥¼ ìœ„í•´ ì—¬ê¸°ì„œëŠ” tickets ìì²´ë¥¼ ì •ë ¬í•©ë‹ˆë‹¤.
        Arrays.sort(tickets, (a, b) -> {
            if(a[0].equals(b[0])) return a[1].compareTo(b[1]);
            return a[0].compareTo(b[0]);
        });
        
        visited = new boolean[tickets.length];
        allRoute = new ArrayList<>();
        
        // ê²½ë¡œ íƒìƒ‰ ì‹œì‘
        dfs("ICN", "ICN", tickets, 0);
        
        return allRoute.get(0).split(" ");
    }
    
    public boolean dfs(String start, String route, String[][] tickets, int cnt){
        // ëª¨ë“  í‹°ì¼“ì„ ì‚¬ìš©í–ˆì„ ë•Œ (ê¸°ì € ì¡°ê±´)
        if(cnt == tickets.length){
            allRoute.add(route);
            return true; // ì •ë‹µì„ ì°¾ì•˜ìœ¼ë¯€ë¡œ true ë°˜í™˜í•˜ì—¬ íƒìƒ‰ ì¢…ë£Œ
        }
        
        for(int i = 0; i < tickets.length; i++){
            // ì¶œë°œì§€ê°€ ì¼ì¹˜í•˜ê³ , ì•„ì§ ì‚¬ìš©í•˜ì§€ ì•Šì€ í‹°ì¼“ì¸ ê²½ìš°
            if(tickets[i][0].equals(start) && !visited[i]){
                visited[i] = true;
                // ì •ë ¬ë˜ì–´ ìˆìœ¼ë¯€ë¡œ ê°€ì¥ ë¨¼ì € ì™„ì„±ëœ ê²½ë¡œê°€ ì•ŒíŒŒë²³ ìˆœì„œìƒ ì•ì„¬
                if(dfs(tickets[i][1], route + " " + tickets[i][1], tickets, cnt + 1)){
                    return true; 
                }
                visited[i] = false; // ë°±íŠ¸ë˜í‚¹
            }
        }
        return false;
    }
}

```

#### 2. Java: ì „ëµ 2 (ìŠ¤íƒ/ì¬ê·€ - Hierholzerâ€™s Algorithm ì‘ìš©) ğŸ”¥ *ì¶”ì²œ*

ì´ ë°©ì‹ì€ ì½”ë“œê°€ ë§¤ìš° ê°„ê²°í•´ì§€ë©°, ë³„ë„ì˜ `visited` ë°°ì—´ ì—†ì´ ê·¸ë˜í”„ì˜ ê°„ì„ ì„ í•˜ë‚˜ì”© ì œê±°í•˜ë©° ì´ë™í•˜ëŠ” ë°©ì‹ì…ë‹ˆë‹¤.

```java
import java.util.*;

class Solution {
    // ëª©ì ì§€ë“¤ì„ ìš°ì„ ìˆœìœ„ íì— ë‹´ì•„ í•­ìƒ ì•ŒíŒŒë²³ ìˆœìœ¼ë¡œ ë¨¼ì € ë°©ë¬¸í•˜ë„ë¡ í•¨
    Map<String, PriorityQueue<String>> graph = new HashMap<>();
    LinkedList<String> route = new LinkedList<>();

    public String[] solution(String[][] tickets) {
        // 1. ê·¸ë˜í”„ êµ¬ì„± (Min-Heap PriorityQueue ì‚¬ìš©)
        for (String[] t : tickets) {
            graph.putIfAbsent(t[0], new PriorityQueue<>());
            graph.get(t[0]).add(t[1]);
        }

        // 2. DFS ì‹œì‘
        dfs("ICN");

        // 3. ê²°ê³¼ ë°˜í™˜ (Listë¥¼ ë°°ì—´ë¡œ ë³€í™˜)
        return route.toArray(new String[0]);
    }

    public void dfs(String airport) {
        // í•´ë‹¹ ê³µí•­ì—ì„œ ì¶œë°œí•˜ëŠ” í‹°ì¼“ì´ ë‚¨ì•„ìˆëŠ” ë™ì•ˆ ê³„ì† ê¹Šì´ íƒìƒ‰
        while (graph.containsKey(airport) && !graph.get(airport).isEmpty()) {
            // ì•ŒíŒŒë²³ ìˆœì„œê°€ ê°€ì¥ ë¹ ë¥¸ ë„ì°©ì§€ë¥¼ êº¼ëƒ„ (Poll: ê°„ì„  ì‚­ì œ íš¨ê³¼)
            String nextDest = graph.get(airport).poll();
            dfs(nextDest);
        }
        
        // ë” ì´ìƒ ê°ˆ ê³³ì´ ì—†ìœ¼ë©´(ë§‰ë‹¤ë¥¸ ê³³ or ëª¨ë“  í‹°ì¼“ ì†Œì§„) ê²½ë¡œì˜ ë§¨ ì•ì— ì¶”ê°€
        // ìŠ¤íƒì—ì„œ ë¹ ì ¸ë‚˜ì˜¬ ë•Œ ê²½ë¡œê°€ ì—­ìˆœìœ¼ë¡œ ìŒ“ì´ëŠ” ì›ë¦¬
        route.addFirst(airport);
    }
}

```

---

### ğŸŒ ë‹¤êµ­ì–´ ì†”ë£¨ì…˜ (ì „ëµ 2 ê¸°ë°˜)

ê°€ì¥ íš¨ìœ¨ì ì¸ **ì „ëµ 2(ìŠ¤íƒ/ì¬ê·€)** ë°©ì‹ì„ ë‹¤ë¥¸ ì–¸ì–´ë¡œë„ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.

#### C++ Code

```cpp
#include <string>
#include <vector>
#include <algorithm>
#include <map>
#include <queue>

using namespace std;

// ëª©ì ì§€ë¥¼ ì‚¬ì „ìˆœìœ¼ë¡œ ì •ë ¬í•˜ê¸° ìœ„í•´ priority_queue (greater) ì‚¬ìš©
map<string, priority_queue<string, vector<string>, greater<string>>> adj;
vector<string> route;

void dfs(string u) {
    // ê°ˆ ìˆ˜ ìˆëŠ” ê²½ë¡œê°€ ìˆë‹¤ë©´ ê³„ì† ê¹Šì´ ë“¤ì–´ê°
    while (adj.find(u) != adj.end() && !adj[u].empty()) {
        string v = adj[u].top();
        adj[u].pop(); // í‹°ì¼“ ì‚¬ìš© (ê°„ì„  ì œê±°)
        dfs(v);
    }
    // ë” ì´ìƒ ê°ˆ ê³³ì´ ì—†ì„ ë•Œ ê²½ë¡œì— ì¶”ê°€ (ì—­ìˆœìœ¼ë¡œ ìŒ“ì„)
    route.push_back(u);
}

vector<string> solution(vector<vector<string>> tickets) {
    for (auto& t : tickets) {
        adj[t[0]].push(t[1]);
    }
    
    dfs("ICN");
    
    // ì—­ìˆœìœ¼ë¡œ ìŒ“ì˜€ìœ¼ë¯€ë¡œ ë’¤ì§‘ì–´ì¤Œ
    reverse(route.begin(), route.end());
    return route;
}

```

#### JavaScript Code

```javascript
function solution(tickets) {
    const graph = {};
    
    // ê·¸ë˜í”„ ìƒì„±
    for (const [src, dest] of tickets) {
        if (!graph[src]) graph[src] = [];
        graph[src].push(dest);
    }
    
    // ë„ì°©ì§€ ê¸°ì¤€ ì•ŒíŒŒë²³ ì—­ìˆœ ì •ë ¬ (pop()ì„ íš¨ìœ¨ì ìœ¼ë¡œ ì“°ê¸° ìœ„í•´)
    for (const key in graph) {
        graph[key].sort((a, b) => a < b ? 1 : -1);
    }
    
    const route = [];
    
    function dfs(airport) {
        const destinations = graph[airport];
        
        // ê°ˆ ê³³ì´ ë‚¨ì•„ìˆë‹¤ë©´
        while (destinations && destinations.length > 0) {
            // ì•ŒíŒŒë²³ ìˆœì„œê°€ ë¹ ë¥¸ ê²ƒì„ êº¼ëƒ„ (ì—­ìˆœ ì •ë ¬í–ˆìœ¼ë¯€ë¡œ popì´ ê°€ì¥ ë¹ ë¥¸ ê²ƒ)
            const nextNode = destinations.pop();
            dfs(nextNode);
        }
        // ë” ì´ìƒ ê°ˆ ê³³ì´ ì—†ìœ¼ë©´ ê²½ë¡œì— ì¶”ê°€ (ì—­ìˆœ)
        route.push(airport);
    }
    
    dfs("ICN");
    
    return route.reverse();
}

```

#### Rust Code

```rust
use std::collections::{HashMap, BinaryHeap};
use std::cmp::Reverse;

pub fn solution(tickets: Vec<Vec<String>>) -> Vec<String> {
    let mut graph: HashMap<String, BinaryHeap<Reverse<String>>> = HashMap::new();

    // ê·¸ë˜í”„ êµ¬ì„±: Min-Heapì„ ìœ„í•´ Reverse ì‚¬ìš©
    for ticket in tickets {
        graph.entry(ticket[0].clone())
             .or_insert_with(BinaryHeap::new)
             .push(Reverse(ticket[1].clone()));
    }

    let mut route: Vec<String> = Vec::new();
    
    // DFS í•¨ìˆ˜ (í´ë¡œì €ë¡œ êµ¬í˜„í•˜ê±°ë‚˜ ë³„ë„ í•¨ìˆ˜ ë¶„ë¦¬ ê°€ëŠ¥í•˜ë‚˜, Rust ì†Œìœ ê¶Œ ë¬¸ì œë¡œ ì¬ê·€ êµ¬ì¡° ì£¼ì˜)
    // ì—¬ê¸°ì„œëŠ” ëª…ì‹œì  ìŠ¤íƒì„ ì‚¬ìš©í•œ ë°˜ë³µë¬¸ ë°©ì‹ì´ ë” ê¹”ë”í•  ìˆ˜ ìˆìœ¼ë‚˜,
    // ì„¤ëª…ì˜ ì¼ê´€ì„±ì„ ìœ„í•´ ì¬ê·€ ë¡œì§ì„ Helper í•¨ìˆ˜ë¡œ ë¶„ë¦¬í•©ë‹ˆë‹¤.
    dfs(&mut graph, "ICN".to_string(), &mut route);
    
    // ê²°ê³¼ ë’¤ì§‘ê¸°
    route.reverse();
    route
}

fn dfs(graph: &mut HashMap<String, BinaryHeap<Reverse<String>>>, u: String, route: &mut Vec<String>) {
    while let Some(dest_wrapper) = graph.get_mut(&u).and_then(|heap| heap.pop()) {
        let dest = dest_wrapper.0;
        dfs(graph, dest, route);
    }
    route.push(u);
}

```

---

### ğŸ” ì•Œê³ ë¦¬ì¦˜ ìƒì„¸ í•´ì„¤ (ì „ëµ 2: ìŠ¤íƒ/ì¬ê·€ ë°©ì‹)

ì´ ë°©ì‹ì´ ì™œ ì‘ë™í•˜ëŠ”ì§€ ì´í•´í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤. í•µì‹¬ì€ **"ë“¤ì–´ê°”ë‹¤ê°€ ë‚˜ì˜¤ë©´ì„œ ê²½ë¡œë¥¼ ê¸°ë¡í•œë‹¤"**ì…ë‹ˆë‹¤.

#### 1. ì‘ë™ ì›ë¦¬ (Diagram)

`[["ICN", "SFO"], ["ICN", "ATL"], ["SFO", "ATL"], ["ATL", "ICN"], ["ATL", "SFO"]]` ì˜ˆì œë¥¼ ë´…ì‹œë‹¤.
(ì•ŒíŒŒë²³ ìˆœì„œì— ë”°ë¼ `ICN -> ATL`ì´ `ICN -> SFO`ë³´ë‹¤ ìš°ì„ ì…ë‹ˆë‹¤.)

**Step 1: ê·¸ë˜í”„ êµ¬ì„± (PriorityQueue)**

* ICN: [ATL, SFO]
* ATL: [ICN, SFO]
* SFO: [ATL]

**Step 2: DFS ì§„í–‰ (Call Stack)**

1. `dfs("ICN")` í˜¸ì¶œ. `ICN`ì—ì„œ `ATL`ì„ êº¼ëƒ„ (ë‚¨ì€ ICN: [SFO]). -> `dfs("ATL")` í˜¸ì¶œ
2. `ATL`ì—ì„œ `ICN`ì„ êº¼ëƒ„ (ë‚¨ì€ ATL: [SFO]). -> `dfs("ICN")` í˜¸ì¶œ
3. `ICN`ì—ì„œ `SFO`ë¥¼ êº¼ëƒ„ (ë‚¨ì€ ICN: []). -> `dfs("SFO")` í˜¸ì¶œ
4. `SFO`ì—ì„œ `ATL`ì„ êº¼ëƒ„ (ë‚¨ì€ SFO: []). -> `dfs("ATL")` í˜¸ì¶œ
5. `ATL`ì—ì„œ `SFO`ë¥¼ êº¼ëƒ„ (ë‚¨ì€ ATL: []). -> `dfs("SFO")` í˜¸ì¶œ
6. `SFO`ëŠ” ê°ˆ ê³³ì´ ì—†ìŒ (ë‚¨ì€ SFO: []).
* **Action:** `route` ë¦¬ìŠ¤íŠ¸ ë§¨ ì•ì— `SFO` ì¶”ê°€. `dfs` ì¢…ë£Œ. (Route: `[SFO]`)


7. (5ë²ˆìœ¼ë¡œ ë³µê·€) `dfs("ATL")`ì˜ whileë¬¸ ì¢…ë£Œ.
* **Action:** `route` ë¦¬ìŠ¤íŠ¸ ë§¨ ì•ì— `ATL` ì¶”ê°€. (Route: `[ATL, SFO]`)


8. ... (ì´ ê³¼ì •ì´ ë°˜ë³µë˜ë©° ì—­ìˆœìœ¼ë¡œ ìŒ“ì„)

ìµœì¢… `route`: `["ICN", "ATL", "ICN", "SFO", "ATL", "SFO"]`

#### 2. ë³µì¡ë„ ë¶„ì„

* **ì‹œê°„ ë³µì¡ë„**:
* ê° í‹°ì¼“(ê°„ì„ )ì„ ê·¸ë˜í”„ì— ë„£ì„ ë•Œ ì •ë ¬(PriorityQueue ì‚½ì…) ë¹„ìš©ì´ ë“­ë‹ˆë‹¤. í‹°ì¼“ ìˆ˜ë¥¼ ì´ë¼ í•  ë•Œ .
* DFS íƒìƒ‰ì€ ëª¨ë“  ê°„ì„ ì„ í•œ ë²ˆì”©ë§Œ ì§€ë‚˜ë¯€ë¡œ .
* ìµœì¢… ì‹œê°„ ë³µì¡ë„ëŠ” ì •ë ¬ ë¹„ìš©ì— ì§€ë°°ë˜ì–´ $O(N \log N)$ì…ë‹ˆë‹¤.


* **ê³µê°„ ë³µì¡ë„**:
* ê·¸ë˜í”„ë¥¼ ì €ì¥í•˜ëŠ” ë° ë§Œí¼ì˜ ê³µê°„ì´ í•„ìš”í•©ë‹ˆë‹¤.
* ì¬ê·€ í˜¸ì¶œ ìŠ¤íƒ(ë˜ëŠ” ê²½ë¡œ ì €ì¥ ë°°ì—´) ë˜í•œ ìµœëŒ€ ì— ë¹„ë¡€í•©ë‹ˆë‹¤.



---

### ğŸŒŸ ë©˜í† ì˜ ì¡°ì–¸ (Comparison)

| íŠ¹ì§• | ì‚¬ìš©ìë‹˜ì˜ ì½”ë“œ (ì™„ì „íƒìƒ‰ + ì‚¬í›„ì •ë ¬) | ì¶”ì²œ ì½”ë“œ 1 (DFS + ì„ ì •ë ¬) | ì¶”ì²œ ì½”ë“œ 2 (ì˜¤ì¼ëŸ¬ ê²½ë¡œ/ìŠ¤íƒ) |
| --- | --- | --- | --- |
| **í•µì‹¬ ë¡œì§** | ëª¨ë“  ê²½ë¡œ íƒìƒ‰ í›„ ì •ë ¬ | ê²½ë¡œ íƒìƒ‰ ì¤‘ ì•ŒíŒŒë²³ ìˆœ ì„ íƒ | ê°„ì„  ì†Œê±°ë²• (Post-order) |
| **íš¨ìœ¨ì„±** | ë‚®ìŒ (ëª¨ë“  ê²½ë¡œ ì €ì¥ ì‹œ ë©”ëª¨ë¦¬ í¼) | ë†’ìŒ (ì²« ê²½ë¡œ ë°œê²¬ ì‹œ ì¢…ë£Œ) | **ë§¤ìš° ë†’ìŒ** (ë¶ˆí•„ìš”í•œ ë˜ëŒë¦¬ê¸° ì—†ìŒ) |
| **ì½”ë“œ ë³µì¡ë„** | ë³´í†µ | ë³´í†µ | **ë§¤ìš° ê°„ê²°** |
| **ì§ê´€ì„±** | ì§ê´€ì  | ì§ê´€ì  | ë‹¤ì†Œ ë‚œí•´í•  ìˆ˜ ìˆìŒ (ê°œë… ì´í•´ í•„ìš”) |

ì‚¬ìš©ìë‹˜ê»˜ì„œ ì‘ì„±í•˜ì‹  ì½”ë“œëŠ” ë¬¸ì œ í•´ê²°ì˜ ì •ì„ì ì¸ ê³¼ì •ì„ ì˜ ë”°ë¥´ê³  ìˆìŠµë‹ˆë‹¤. ì´ì œ **ìë£Œêµ¬ì¡°(PriorityQueue)ë¥¼ í™œìš©í•œ ì •ë ¬ ìë™í™”**ì™€ **ê·¸ë˜í”„ ì´ë¡ (ì˜¤ì¼ëŸ¬ ê²½ë¡œ)**ì„ ì ìš©í•œ ë°©ì‹ì„ ìµíˆì‹ ë‹¤ë©´, í›¨ì”¬ ë” ë³µì¡í•œ ë¬¸ì œë„ íš¨ìœ¨ì ìœ¼ë¡œ í‘¸ì‹¤ ìˆ˜ ìˆì„ ê²ƒì…ë‹ˆë‹¤.

**ë‹¤ìŒ ë‹¨ê³„ ì œì•ˆ:**
í˜¹ì‹œ ìœ„ì—ì„œ ì„¤ëª…í•´ ë“œë¦° **"ìŠ¤íƒ/ì¬ê·€ ë°©ì‹ì˜ ì‘ë™ ì›ë¦¬"**ì— ëŒ€í•´ ê·¸ë¦¼ìœ¼ë¡œ ë” ìì„¸í•œ ì„¤ëª…ì´ í•„ìš”í•˜ì‹œê±°ë‚˜, ë‹¤ë¥¸ ê·¸ë˜í”„ ë¬¸ì œ(ì˜ˆ: ìˆœìœ„, ê°€ì¥ ë¨¼ ë…¸ë“œ ë“±)ì— ëŒ€í•œ í’€ì´ê°€ ê¶ê¸ˆí•˜ì‹œë‹¤ë©´ ì–¸ì œë“  ë§ì”€í•´ ì£¼ì„¸ìš”!