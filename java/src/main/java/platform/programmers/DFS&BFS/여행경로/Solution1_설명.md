
### 1. 코드 상세 분석 및 해설

이 코드의 핵심은 **"모든 경로를 다 가보는 것이 아니라, 알파벳 순서대로 시도하다가 성공하면 그 길로 확정"** 짓는 것입니다.

#### 주요 흐름 단계별 설명

1. **전처리 (Sorting)**
* `Arrays.sort(tickets, ...)`: 티켓 목록을 미리 정렬합니다.
* 이유: DFS 탐색 시 `for` 문을 0부터 순회하는데, 이때 **알파벳 순서가 빠른 목적지가 담긴 티켓을 먼저 만나게 하기 위함**입니다.


2. **탐색 시작 (Entry Point)**
* `dfs("ICN", "ICN", tickets, 0);`
* 문제 조건에 따라 무조건 **"ICN"**에서 시작합니다. (이 부분이 두 번째 질문의 핵심 답이 됩니다.)


3. **DFS 함수 내부 (Recursive Step)**
* **기저 조건 (Base Case)**: `if(cnt == tickets.length)`
* 티켓을 모두 다 썼다면, 지금 완성된 `route`가 정답입니다.
* `return true`를 통해 "나 정답 찾았으니 더 이상 딴짓하지 말고 끝내자!"라는 신호를 보냅니다.


* **반복 및 가지치기 (Loop & Pruning)**:
* `for` 문으로 티켓 배열을 처음부터 훑습니다.
* `if(tickets[i][0].equals(start) && !visited[i])`: 현재 내가 있는 공항(`start`)에서 출발하고, 아직 안 쓴 티켓인지 확인합니다.
* **중요:** 티켓이 정렬되어 있으므로, 이 조건을 만족하는 첫 번째 티켓이 **알파벳 순서상 가장 빠른 목적지**입니다.




4. **재귀 호출 및 백트래킹 (Backtracking)**
* `visited[i] = true;`: 티켓을 사용 처리합니다.
* `if(dfs(..., cnt + 1)) return true;`:
* 다음 단계로 넘어갑니다.
* 만약 깊숙이 들어갔다가 **`true`가 반환되어 돌아왔다면**, "아래쪽에서 완벽한 경로를 찾았다"는 뜻입니다. 그러므로 나도 즉시 `return true`를 하여 탐색을 종료합니다. (더 뒷순위 알파벳 경로는 볼 필요가 없어짐)


* `visited[i] = false;`:
* 만약 위 `dfs` 호출에서 `false`가 돌아왔다면? "이 티켓을 쓰고 들어가 봤더니 길이 막혀서(모든 도시 방문 불가) 실패했다"는 뜻입니다.
* 따라서 다시 티켓을 미사용 상태로 돌려놓고(`false`), 다음 티켓(반복문의 다음 `i`)을 시도합니다.





---

### 2. 정렬(Sorting)과 시작 공항("ICN")에 대한 의문 해결

사용자님께서 아주 예리한 질문을 해주셨습니다.

> **"정렬을 하면 ICN보다 알파벳이 앞서는 공항(예: ATL)이 배열의 앞쪽에 올 텐데, 어떻게 ICN부터 시작하나요?"**

이 의문을 해결하기 위해 **"데이터의 저장 순서"**와 **"코드의 실행 순서"**를 구분해야 합니다.

#### 핵심: `dfs` 함수의 첫 번째 인자가 필터 역할을 합니다.

`Arrays.sort`는 티켓들이 배열(`tickets`)에 저장되는 순서만 바꿀 뿐입니다. 하지만 우리가 탐색을 할 때는 무조건 **"ICN"**이라는 조건을 들고 반복문을 돕니다.

**예시를 들어 시뮬레이션 해보겠습니다.**

**주어진 티켓:** `[["ICN", "SFO"], ["ICN", "ATL"], ["ATL", "ICN"]]`

**1. `Arrays.sort` 실행 후 배열 상태**
배열 인덱스 순서대로 정렬됩니다. ("ATL"이 "ICN"보다 앞서니까요)

* `idx 0`: `["ATL", "ICN"]`
* `idx 1`: `["ICN", "ATL"]`
* `idx 2`: `["ICN", "SFO"]`
  *(말씀하신 대로 ICN이 아닌 티켓이 배열 앞쪽에 왔습니다.)*

**2. `solution` 함수에서 탐색 시작**

```java
// 무조건 출발지를 "ICN"으로 고정하고 호출합니다.
dfs("ICN", "ICN", tickets, 0); 

```

**3. `dfs` 내부의 `for` 문 동작**
`start` 변수에는 현재 **"ICN"**이 들어있습니다.

* **`i = 0` 일 때 (`["ATL", "ICN"]` 확인):**
* 조건: `if(tickets[0][0].equals("ICN") ...)`
* `"ATL"`은 `"ICN"`이 아닙니다. **조건 불일치로 건너뜁니다.**
* *(배열 앞에 있어도 출발지가 안 맞으면 무시됩니다.)*


* **`i = 1` 일 때 (`["ICN", "ATL"]` 확인):**
* 조건: `if(tickets[1][0].equals("ICN") ...)`
* **일치합니다!**
* 이 티켓을 사용(`visited[1]=true`)하고 `ATL`로 이동합니다.


* **`i = 2` 일 때 (`["ICN", "SFO"]` 확인):**
* `i=1`에서의 재귀 호출이 성공해서 `true`를 리턴하면 이 순서는 오지 않습니다.
* 만약 `i=1` 경로가 실패했다면 백트래킹 후 이 티켓을 보게 됩니다.



#### 결론

`Arrays.sort`의 목적은 시작점을 결정하는 것이 아니라, **"출발지가 같은 티켓이 여러 장 있을 때, 목적지(도착 공항)를 알파벳 순서대로 배치해 두는 것"**입니다.

이렇게 해두면 `dfs` 함수 내부에서 `for` 문을 돌 때, 출발지(`start`)가 같은 티켓들 중 **가장 알파벳이 빠른 목적지부터 자동으로 먼저 선택**하게 되는 효과가 있습니다.

이해가 되셨나요?
요약하자면, **"배열의 순서는 뒤죽박죽이 되어도, `dfs` 함수가 `start` 파라미터로 철저하게 내가 출발해야 할 공항만 골라내기 때문에 문제없다"**입니다.