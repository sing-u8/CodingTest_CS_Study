작성하신 코드는 그래프 이론에서 **"연결 요소(Connected Component)의 개수 구하기"**라는 문제를 해결하는 가장 정석적인 방법인 **DFS(깊이 우선 탐색)**를 활용한 풀이입니다.

이 코드가 왜 이렇게 작성되었는지, **근본 원리(Core Principle)**와 **코드의 동작 흐름**을 비유를 섞어 아주 상세하게 설명해 드리겠습니다.

---
## 1. DFS
### 1. 근본 원리: 땅따먹기 (혹은 섬 개수 세기)

이 문제를 직관적으로 이해하려면 **"지도에서 섬의 개수 세기"**라고 생각하면 가장 쉽습니다.

* **컴퓨터**: 땅(지역)
* **연결**: 다리(Bridge)
* **네트워크**: 다리로 연결된 땅들의 덩어리(하나의 섬)
* **`visit` 배열**: 깃발 꽂기 (이미 밟은 땅 표시)

작성하신 코드의 전략은 다음과 같습니다.

1. **전체 탐색**: 1번 땅부터 n번 땅까지 순서대로 훑어봅니다.
2. **새로운 섬 발견**: 만약 어떤 땅에 도착했는데 깃발이 없다면(`!visit[i]`), 그곳은 **새로운 섬(네트워크)의 시작점**입니다. (이때 `answer++`)
3. **영역 확장 (DFS)**: 그 땅에서 시작해서 다리로 연결된 모든 땅을 찾아다니며 깃발을 꽂습니다. 연결된 곳이 없을 때까지 끝까지 들어갑니다.
4. **복귀 및 반복**: 더 이상 갈 곳이 없으면 돌아옵니다. 이제 다음 번호의 땅을 보는데, 만약 이미 깃발이 꽂혀있다면(앞선 탐색에서 방문했다면) 그 땅은 이미 센 섬의 일부이므로 무시합니다.

---

### 2. 코드 상세 분석

코드를 블록별로 나누어 각 줄이 존재하는 이유를 설명하겠습니다.

#### **A. 준비 단계 (`solution` 함수 초반)**

```java
int answer = 0; // 네트워크(섬)의 개수
boolean[] visit = new boolean[n]; // 방문 체크 배열 (깃발)

```

* **`visit` 배열이 필요한 이유 (핵심)**:
* 그래프 탐색에서 가장 중요한 것은 **무한 루프 방지**와 **중복 카운팅 방지**입니다.
* A와 B가 연결되어 있을 때, A에서 B로 갔다가 다시 B에서 A로 돌아오는 것을 막기 위해 "여긴 이미 왔다 감"이라고 표시해두는 메모장입니다.



#### **B. 전체 스캔 루프 (`solution` 함수 중반)**

```java
for (int i = 0; i < n; i++) { // 모든 컴퓨터를 하나씩 순서대로 확인
    if(!visit[i]) {           // "아직 방문하지 않은 컴퓨터"라면? -> 새로운 네트워크 발견!
        dfs(n, computers, i, visit); // 그 네트워크에 속한 모든 컴퓨터를 찾아 깃발 꽂고 와라!
        answer++;             // 네트워크 하나 찾았으니 카운트 +1
    }
}

```

* **`if(!visit[i])`의 의미**:
* 만약 `i`번 컴퓨터가 이미 `true`라면, 이전 루프(예: `i-1`번 등을 처리할 때)에서 이미 연결되어 카운팅이 끝난 네트워크의 일부라는 뜻입니다. 따라서 그냥 넘어갑니다.
* `false`라면, 지금까지 발견된 어떤 네트워크와도 연결되지 않은 **새로운 그룹의 시작**이라는 뜻입니다.



#### **C. 깊이 우선 탐색 (`dfs` 함수)**

```java
public void dfs(int n, int[][] computers, int idx, boolean[] visit) {
    visit[idx] = true; // 1. 현재 컴퓨터에 깃발 꽂기 (방문 처리)

    for (int i = 0; i < n; i++) { // 2. 다른 모든 컴퓨터들과의 연결 관계 확인
        // 핵심 조건문:
        // (1) idx != i : 자기 자신이 아니고
        // (2) visit[i] == false : 아직 방문 안 했고 (이미 간 곳은 안 감)
        // (3) computers[idx][i] == 1 : 실제로 연결되어 있다면
        if (idx != i && visit[i] == false && computers[idx][i] == 1) {
            dfs(n, computers, i, visit); // 3. 그 컴퓨터로 이동해서 다시 탐색 시작 (재귀)
        }
    }
}

```

* **재귀(Recursion)의 역할**:
* `dfs` 함수 안에서 다시 `dfs`를 부르는 것은 **"꼬리에 꼬리를 물고 들어가는 것"**입니다.
* A와 B가 연결됨 -> B로 이동 -> B와 C가 연결됨 -> C로 이동 ... -> 더 이상 갈 곳 없으면 종료.
* 이 과정이 끝나면, 시작점(`idx`)과 직/간접적으로 연결된 **모든** 컴퓨터의 `visit` 배열이 `true`로 변하게 됩니다.



---

### 3. 예제로 보는 동작 과정 (입출력 예 #1)

* **입력**: `n=3`, `[[1, 1, 0], [1, 1, 0], [0, 0, 1]]` (0번-1번 연결, 2번 독립)

**[Step 1] `solution` 함수 `i = 0` 일 때**

1. `visit[0]`은 `false`입니다. **새로운 네트워크 발견!**
2. `dfs(..., 0, ...)` 호출.
* 0번 컴퓨터 방문 처리 (`visit[0] = true`).
* 0번과 연결된 곳 확인: **1번 컴퓨터**가 연결되어 있고 방문 안 했음(`computers[0][1]==1`).
* `dfs(..., 1, ...)` 호출 (0번에서 1번으로 이동).
* 1번 컴퓨터 방문 처리 (`visit[1] = true`).
* 1번과 연결된 곳 확인: 0번은 연결됐지만 이미 방문했음(`visit[0]==true`). 2번은 연결 안 됨.
* 더 갈 곳이 없으므로 `dfs(1)` 종료.


* `dfs(0)`도 더 갈 곳이 없으므로 종료.


3. `answer`를 1 증가시킵니다. (`answer = 1`)
* 현재 상태: `visit = [true, true, false]`



**[Step 2] `solution` 함수 `i = 1` 일 때**

1. `visit[1]`을 보니 `true`입니다. (아까 0번 볼 때 같이 처리됨)
2. 이미 센 네트워크이므로 **패스**.

**[Step 3] `solution` 함수 `i = 2` 일 때**

1. `visit[2]`는 `false`입니다. **또 다른 새로운 네트워크 발견!**
2. `dfs(..., 2, ...)` 호출.
* 2번 컴퓨터 방문 처리 (`visit[2] = true`).
* 2번과 연결된 곳 확인: 없음.
* 종료.


3. `answer`를 1 증가시킵니다. (`answer = 2`)
* 현재 상태: `visit = [true, true, true]`



**[최종]** 루프 종료, `answer`인 **2**를 반환.

---

### 4. 멘토의 요약 및 팁

1. **DFS/BFS 선택**: 이 문제는 **"연결되어 있는 덩어리의 개수"**를 묻는 문제이므로, **DFS(깊이 우선 탐색)**나 **BFS(너비 우선 탐색)** 둘 다 사용 가능합니다. 작성하신 DFS 방식은 코드가 간결하여 아주 좋은 선택입니다.
2. **시간 복잡도**: $O(N^2)$입니다. `dfs` 함수 내에서 `for`문이 번 돌고, 각 정점마다 한 번씩 방문하므로 전체적으로  만큼의 확인 작업을 거칩니다. 이 200 이하이므로 충분히 통과합니다.
3. **핵심 포인트**: `if(!visit[i])` 조건이 이 알고리즘의 **심장**입니다. 이 조건 덕분에 이미 센 네트워크를 중복해서 세지 않게 됩니다.

작성하신 코드는 군더더기 없이 아주 깔끔한 정석 풀이입니다. 이 로직을 잘 기억해두시면, 나중에 **"바이러스 퍼뜨리기"**, **"영역 넓이 구하기"** 같은 문제도 똑같은 원리로 해결할 수 있습니다! 👍


## 2.BFS
DFS가 **"한 놈만 팬다(한 길로 끝까지 간다)"**는 식이라면, BFS는 **"내 주위부터 챙긴다(가까운 곳부터 넓게 퍼진다)"**는 방식입니다.

구현상의 가장 큰 차이점은 DFS는 **재귀(Recursion)**나 스택을 쓰지만, BFS는 **큐(Queue)**를 사용한다는 점입니다.

### [Java] BFS를 이용한 네트워크 풀이

```java
import java.util.*;

class Solution {
    public int solution(int n, int[][] computers) {
        int answer = 0;
        boolean[] visit = new boolean[n]; // 방문 여부 체크 (깃발)

        // 1. 모든 컴퓨터를 순회하며 네트워크 탐색
        for (int i = 0; i < n; i++) {
            if (!visit[i]) {
                // 아직 방문하지 않은 컴퓨터라면 새로운 네트워크의 시작점
                bfs(n, computers, i, visit);
                answer++;
            }
        }
        return answer;
    }

    // BFS 함수: 큐(Queue)를 사용하여 연결된 모든 노드를 넓게 탐색
    public void bfs(int n, int[][] computers, int start, boolean[] visit) {
        Queue<Integer> q = new LinkedList<>();
        
        // 시작점 큐에 넣고 방문 처리
        q.offer(start);
        visit[start] = true;

        while (!q.isEmpty()) {
            // 큐에서 컴퓨터 하나를 꺼냄
            int current = q.poll();

            // 꺼낸 컴퓨터와 연결된 다른 컴퓨터들을 찾음
            for (int i = 0; i < n; i++) {
                // (1) 연결되어 있고 (2) 아직 방문 안 했으면
                if (computers[current][i] == 1 && !visit[i]) {
                    visit[i] = true; // 방문 처리 (깃발 꽂기)
                    q.offer(i);      // 큐에 대기 시킴
                }
            }
        }
    }
}

```

---

### 🔍 BFS 동작 원리 상세 설명 (비유: 전염병 확산)

BFS는 **전염병이 퍼지는 과정**이나 **물에 돌을 던졌을 때 파동이 퍼지는 것**과 똑같습니다.

1. **큐(Queue) 준비**: 감염될 대기 명단이라고 생각하세요.
2. **`q.offer(start)`**: 첫 번째 컴퓨터(환자)가 발생했습니다. 대기 명단에 넣습니다.
3. **`while (!q.isEmpty())`**: 대기 명단에 사람이 있는 한 계속합니다.
4. **`q.poll()`**: 대기 명단 맨 앞사람(`current`)을 꺼내서 조사합니다.
5. **`for` 문 (전파)**: `current`와 연결된 사람(`i`)들을 봅니다.
* 만약 `i`가 아직 감염 안 됐으면(`!visit[i]`)?
* **즉시 감염 처리**(`visit[i] = true`)하고 **대기 명단에 추가**(`q.offer(i)`)합니다.


6. 이 과정을 반복하면, 시작점과 연결된 모든 컴퓨터가 방문 처리(`true`) 되고 큐가 비게 됩니다.

---

### 📊 DFS vs BFS 비교 (이 문제에서)

| 특징 | DFS (깊이 우선 탐색) | BFS (너비 우선 탐색) |
| --- | --- | --- |
| **구현 도구** | **재귀 함수** (시스템 스택) | **Queue** (대기열 자료구조) |
| **탐색 순서** | 한 경로를 끝까지 파고듦 | 인접한 노드들을 먼저 다 훑음 |
| **메모리** | 경로가 깊을수록 스택 메모리 사용 | 넓이가 넓을수록 큐 메모리 사용 |
| **코드 길이** | 재귀라 보통 더 짧음 | 큐 선언 등 때문에 약간 더 김 |
| **이 문제 적합도** | **매우 적합** | **매우 적합** |

**결론**: 이 문제("연결된 덩어리 개수 세기")에서는 **어느 것을 써도 상관없습니다.** 둘 다 모든 노드를 한 번씩 방문하므로 시간 복잡도는 $O(N^2)$로 동일합니다.

다만, **"최단 거리(가장 짧은 경로)"**를 구해야 하는 문제라면 **BFS**가 훨씬 유리합니다. (DFS는 빙 돌아가는 경로를 먼저 찾을 수도 있기 때문이죠.)

이 BFS 코드도 이해가 쏙쏙 되시나요? BFS를 위한 `Queue` 사용법(`offer`, `poll`, `isEmpty`)만 익히시면 됩니다!