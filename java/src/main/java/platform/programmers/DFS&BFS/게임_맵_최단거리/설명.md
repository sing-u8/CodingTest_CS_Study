이 문제는 **가중치가 없는 2차원 격자(Grid)에서의 최단 거리**를 구하는 전형적인 문제입니다. 결론부터 말씀드리면, **최단 거리 문제에는 BFS(너비 우선 탐색)가 가장 적합**합니다. DFS(깊이 우선 탐색)로도 풀 수는 있지만, 효율성 테스트에서 시간 초과(Time Limit Exceeded)가 발생할 가능성이 매우 높습니다.

---

### 1. BFS (너비 우선 탐색) 풀이 - **[권장 & 정답]**

BFS는 시작 지점에서 가까운 곳부터 한 단계씩(Layer by Layer) 넓혀가며 탐색합니다. 따라서 **목적지에 처음 도달했을 때가 무조건 최단 거리**임이 보장됩니다.

#### BFS 솔루션 코드 (Java)

```java
import java.util.*;

class Solution {
    // 상, 하, 좌, 우 이동을 위한 방향 배열
    int[] dx = {1, -1, 0, 0};
    int[] dy = {0, 0, 1, -1};

    public int solution(int[][] maps) {
        int n = maps.length;
        int m = maps[0].length;

        // 방문 여부를 체크하는 배열 (방문하지 않음: false)
        boolean[][] visited = new boolean[n][m];
        
        // BFS를 위한 큐 생성 (int[] {x, y, 이동거리})
        Queue<int[]> queue = new LinkedList<>();
        
        // 시작 위치 (0, 0)과 초기 거리 1 삽입
        queue.offer(new int[]{0, 0, 1});
        visited[0][0] = true;

        while (!queue.isEmpty()) {
            int[] current = queue.poll();
            int cx = current[0];
            int cy = current[1];
            int dist = current[2];

            // 상대 팀 진영(도착점)에 도달하면 거리 반환
            if (cx == n - 1 && cy == m - 1) {
                return dist;
            }

            // 4방향 탐색
            for (int i = 0; i < 4; i++) {
                int nx = cx + dx[i];
                int ny = cy + dy[i];

                // 맵 범위를 벗어나는지 확인
                if (nx < 0 || nx >= n || ny < 0 || ny >= m) {
                    continue;
                }

                // 벽(0)이거나 이미 방문한 곳이면 패스
                if (maps[nx][ny] == 0 || visited[nx][ny]) {
                    continue;
                }

                // 갈 수 있는 길이면 큐에 넣고 방문 처리
                visited[nx][ny] = true;
                queue.offer(new int[]{nx, ny, dist + 1});
            }
        }

        // 큐가 빌 때까지 도착점에 도달하지 못하면 -1 반환
        return -1;
    }
}

```

#### BFS 알고리즘 해설

1. **큐(Queue) 활용**: 현재 위치에서 갈 수 있는 칸들을 큐에 넣고 순서대로 꺼냅니다.
2. **방문 처리**: 한 번 큐에 들어간(방문한) 칸은 다시 방문하지 않습니다. 이는 최단 거리를 보장하기 위함입니다.
3. **단계별 확장**: 시작점에서 거리가 1인 곳 -> 2인 곳 -> 3인 곳 순서로 탐색하므로, `(n-1, m-1)`에 도달하는 순간이 가장 빠른 경로입니다.
4. **효율성**: 모든 노드를 한 번씩만 방문하므로 시간 복잡도는 $O(N \times M)$입니다.

---

### 2. DFS (깊이 우선 탐색) 풀이 - **[비효율적 / 학습용]**

DFS는 한 우물을 끝까지 파는 방식입니다. 갈 수 있는 길을 끝까지 갔다가 막히면 돌아옵니다(Backtracking).
최단 거리를 구하기 위해서는 **모든 가능한 경로를 다 탐색해본 후, 그중 가장 짧은 것을 선택**해야 합니다. 따라서 이 문제에서는 매우 비효율적입니다.

> **주의:** 아래 코드는 정확성 테스트는 통과할 수 있으나, 맵이 커질 경우(효율성 테스트) **시간 초과**가 발생할 수 있습니다.

#### DFS 솔루션 코드 (Java)

```java
class Solution {
    int[] dx = {1, -1, 0, 0};
    int[] dy = {0, 0, 1, -1};
    int answer = Integer.MAX_VALUE; // 최솟값을 찾기 위해 최댓값으로 초기화
    boolean[][] visited;
    int n, m;

    public int solution(int[][] maps) {
        n = maps.length;
        m = maps[0].length;
        visited = new boolean[n][m];

        // DFS 시작 (x, y, 현재 거리)
        visited[0][0] = true;
        dfs(maps, 0, 0, 1);

        // 도착 못한 경우 -1, 아니면 최솟값 반환
        return answer == Integer.MAX_VALUE ? -1 : answer;
    }

    public void dfs(int[][] maps, int x, int y, int count) {
        // 현재 경로가 이미 찾은 최단 거리보다 길다면 더 이상 탐색할 필요 없음 (가지치기)
        if (count >= answer) {
            return;
        }

        // 도착점에 도달했을 때
        if (x == n - 1 && y == m - 1) {
            answer = Math.min(answer, count);
            return;
        }

        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];

            if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                // 벽이 아니고 방문하지 않은 곳이라면
                if (maps[nx][ny] == 1 && !visited[nx][ny]) {
                    visited[nx][ny] = true; // 방문 체크
                    dfs(maps, nx, ny, count + 1); // 재귀 호출
                    visited[nx][ny] = false; // 백트래킹 (다른 경로를 위해 방문 해제)
                }
            }
        }
    }
}

```

#### DFS 알고리즘 해설 및 한계

1. **재귀와 백트래킹**: 한 경로를 끝까지 탐색한 후, `visited = false`로 되돌려서 다른 경로로도 해당 지점을 갈 수 있게 해줘야 합니다. 그래야 "다른 길로 돌아왔을 때 더 빠른 경우"를 찾을 수 있기 때문입니다.
2. **모든 경로 탐색**: BFS는 도착하면 끝이지만, DFS는 도착해도 끝이 아닙니다. 더 짧은 경로가 있을지 모르니 다른 길도 다 가봐야 합니다.
3. **시간 초과 위험**: 이 100일 때 가능한 경로의 수는 기하급수적으로 늘어납니다. 위 코드에 `if (count >= answer) return;` 같은 가지치기(Pruning)를 넣었지만, 여전히 BFS보다 훨씬 느립니다.

---

### 3. 비교 및 요약

| 특징 | BFS (너비 우선 탐색) | DFS (깊이 우선 탐색) |
| --- | --- | --- |
| **작동 방식** | 물결이 퍼져나가듯 주변부터 탐색 | 미로 찾기하듯 한 길을 끝까지 탐색 |
| **자료구조** | 큐 (Queue) | 스택 (Stack) 또는 재귀 (Recursion) |
| **최단 거리** | **보장함** (가장 먼저 도착한 게 최단) | 보장하지 않음 (모든 경로 비교 필요) |
| **이 문제 적합성** | **★★★★★ (최적)** | ★☆☆☆☆ (비추천, 시간 초과) |

**결론:** 코딩 테스트에서 "최단 거리" 또는 "최소 횟수"를 묻는 문제가 나오면 주저 없이 **BFS**를 선택하세요!


## 참고: Queue타입 변수에 LinkedList를 대입하는 이유

정말 날카롭고 좋은 질문입니다! Java의 컬렉션 프레임워크(Collection Framework) 구조를 이해하는 데 핵심적인 부분입니다.

결론부터 말씀드리면 **`Queue`는 껍데기(인터페이스)이고, `LinkedList`는 알맹이(구현체 클래스)이기 때문**입니다.

이유를 3가지 핵심 포인트로 나누어 명쾌하게 설명해 드리겠습니다.

---

### 1. `Queue`는 "인터페이스(Interface)"입니다.

Java에서 `Queue`는 "클래스"가 아니라 **"인터페이스"**입니다. 인터페이스는 **"기능에 대한 규격(약속)"**만 정의되어 있고, 실제 작동하는 코드는 없습니다.

따라서 인터페이스 자체로는 객체(Instance)를 생성할 수 없습니다.

```java
// [에러 발생] 인터페이스는 new로 생성 불가!
Queue<int[]> q = new Queue<>(); 

```

그렇기 때문에 `Queue`라는 **규격**을 실제로 구현해 놓은 **클래스**인 `LinkedList`를 빌려와서 객체를 생성(`new`)해야 하는 것입니다.

### 2. 다형성 (Polymorphism)과 유연성

"그럼 그냥 `LinkedList<int[]> q = new LinkedList<>();` 라고 쓰면 안 되나요?"라고 물으실 수 있습니다. 물론 그렇게 써도 코드는 정상적으로 돌아갑니다.

하지만 보통 `Queue<int[]> q = ...` 방식을 더 선호합니다. 그 이유는 **"나는 이 변수를 오직 큐(Queue) 용도로만 쓰겠다"**는 의도를 명확히 하기 위해서입니다.

* **`Queue` 타입으로 선언 시:** `offer()`, `poll()`, `peek()` 같은 큐 전용 메서드만 사용할 수 있습니다.
* **`LinkedList` 타입으로 선언 시:** `get(i)`, `set(i)`, `remove(i)` 같은 리스트 용도의 메서드도 사용 가능해집니다.

BFS 알고리즘에서는 중간에 있는 데이터를 건드리면 안 되고 오직 선입선출(FIFO)만 해야 합니다. `Queue` 타입으로 선언하면 실수로 `q.get(0)` 같은 **비효율적인 메서드(LinkedList에서 인덱스 접근은 느림)**를 사용하는 것을 코딩 단계에서 막을 수 있습니다.

### 3. 더 좋은 대안: `ArrayDeque` (꿀팁)

사실 코딩 테스트 고수들은 `LinkedList` 대신 **`ArrayDeque`**를 더 많이 사용합니다.

```java
// 이것이 성능상 더 유리합니다.
Queue<int[]> queue = new ArrayDeque<>();

```

이때 변수 타입을 `Queue`로 선언해 두었다면, 나중에 마음이 바뀌어 구현체를 `LinkedList`에서 `ArrayDeque`로 바꿀 때 뒷부분(`new ...`)만 살짝 고치면 됩니다. 코드를 유연하게 관리할 수 있죠.

#### 왜 `ArrayDeque`가 더 좋나요?

* **`LinkedList`**: 데이터를 담는 노드(Node) 객체를 계속 새로 만듭니다. 메모리가 여기저기 흩어져 있어(비연속적) 캐시 효율이 조금 떨어질 수 있습니다.
* **`ArrayDeque`**: 내부적으로 배열(Array)을 사용합니다. 메모리가 연속적이고 노드 객체 생성 비용이 없어 **속도가 더 빠르고 메모리를 덜 차지합니다.**

---

### 요약

1. **불가피함:** `Queue`는 인터페이스라 `new Queue()`가 불가능해서 구현체인 `LinkedList`나 `ArrayDeque`가 필요합니다.
2. **의도 명확화:** `Queue` 타입으로 선언하면 "나는 큐 기능만 쓰겠다"는 의도를 보여주고 실수를 방지합니다.
3. **추천:** 실제 코딩 테스트에서는 `LinkedList`보다 **`ArrayDeque`**가 성능상 미세하게 더 빠릅니다.

```java
// 추천하는 선언 방식
Queue<int[]> queue = new ArrayDeque<>();

```

## 해당 문제를 BFS로 접근하게 되는 논리적인 사고 흐름

### 1단계: 문제의 핵심 키워드 포착 (Trigger)

문제를 읽으면서 가장 먼저 눈에 들어와야 하는 단어는 바로 **"최단 거리"**와 **"칸의 개수(비용)가 모두 1로 동일함"**입니다.

* **문제 문구:** "지나가야 하는 칸의 개수의 **최솟값**"
* **환경:** "한 칸씩 이동" (즉, 가중치가 없는 그래프)

> **🧠 뇌의 반응:**
> "가중치가 없는 그래프(격자)에서 시작점부터 끝점까지의 최단 거리? 이건 99% **BFS**다."

---

### 2단계: 후보 알고리즘 비교 및 검증 (Why not DFS?)

왜 DFS는 안 될까요? 논리적으로 시뮬레이션을 돌려봅니다.

* **DFS의 사고방식 (미로 탐험가):**
  "나는 한 놈만 팬다. 일단 길이 보이면 막다른 골목이 나올 때까지 무조건 깊게 들어간다."
* **문제점:** 운 좋게 바로 목적지에 도착하면 다행이지만, 만약 꼬불꼬불하게 돌아가는 길을 먼저 선택했다면? 그게 최단 거리인지 알 방법이 없습니다.
* **결과:** 최단 거리를 찾으려면 **모든 가능한 경로를 다 탐색해본 뒤 비교**해야 합니다. 이 100이면 경우의 수가 너무 많아 **시간 초과(Time Out)** 확정입니다.


* **BFS의 사고방식 (호수의 물결):**
  "나는 공평하다. 내 위치에서 1칸 거리인 곳을 다 보고, 그 다음 2칸 거리인 곳을 다 본다."
* **장점:** 시작점에서 1칸, 2칸, 3칸... 순서대로 영역을 넓혀갑니다. 그러다가 목적지에 **"딱!" 닿는 그 순간**이 무조건 가장 빨리 도착한 순간입니다.
* **결과:** 목적지를 발견하자마자 탐색을 종료해도 되므로 **효율적**입니다.



---

### 3단계: 논리적 구체화 (시각적 상상)

이제 BFS로 결정했으니, 머릿속으로 알고리즘이 돌아가는 모습을 그려봅니다. 이를 **"Layer by Layer (계층별 탐색)"**이라고 합니다.

**[상상 속 시뮬레이션]**

1. **Start (Layer 0):** (1,1)에 내가 서 있다. (거리: 1)
2. **Layer 1:** 여기서 한 발자국 움직여 갈 수 있는 칸들을 다 찾아서 큐에 넣는다. (거리: 2인 칸들)
3. **Layer 2:** 방금 큐에 넣은 칸들에서 다시 한 발자국 더 가서 닿는 칸들을 찾는다. (거리: 3인 칸들)
* *단, 이미 왔던 길(방문한 곳)은 제외한다.*


4. **Target Hit:** 이렇게 퍼져 나가다가 상대 진영(N, M)을 큐에서 꺼내는 순간? -> **게임 끝. 그 거리가 정답.**

---

### 4단계: 자료구조 매핑 (Implementation Strategy)

이제 사고한 내용을 코드로 옮길 준비를 합니다.

1. **"순서대로 넓혀가야 해"**
*  먼저 발견한 곳을 먼저 처리해야 하니 **FIFO(선입선출)** 구조인 **`Queue`**가 필요하겠군.


2. **"왔던 길을 되돌아가면 안 돼"**
*  중복 방지를 위한 **`boolean[][] visited`** 배열이 필요하겠군. (혹은 `maps` 값을 0으로 바꿔서 벽으로 만들어버릴까? -> 이것도 가능)


3. **"거리를 어떻게 기억하지?"**
*  큐에 좌표 `(x, y)`만 넣지 말고, `(x, y, 현재거리)`를 같이 묶어서 넣자. (`int[]` 또는 클래스 활용)


4. **"상하좌우 이동은?"**
*  `dx`, `dy` 배열(델타 탐색)을 써서 `for`문으로 돌리면 깔끔하겠군.



---

### 요약: 사고의 흐름 3줄 정리

1. **문제 인식:** "격자판 최단 거리 문제네?"
2. **알고리즘 선택:** "모든 간선의 비용이 1이니까, 물결처럼 퍼지는 **BFS**가 최단 경로 보장 및 최적이다." (DFS는 돌아갈 위험이 큼)
3. **구현 설계:** "큐(`Queue`)를 써서 방문 순서를 관리하고, `visited`로 중복을 막으며 목적지에 닿을 때까지 퍼뜨리자."

이 흐름이 익숙해지면 문제를 읽자마자 "아, 이건 BFS+큐 문제네" 하고 바로 코드를 치기 시작하는 경지에 오르게 됩니다!