# 📝 [알고리즘 노트] 기하/좌표 문제 완전 정복 : 아이템 줍기
## [Cheat Sheet] 좌표/기하 문제 해결 5대 원칙

이 원칙들만 기억해도 구현 실수(Bug)를 획기적으로 줄일 수 있습니다.

### ① (x, y)와 (행, 열)의 괴리 해결

수학 좌표계와 프로그래밍 배열은 기준이 다릅니다. 혼동을 막기 위해 기준을 정해야 합니다.

* **수학:**   가로 , 세로  (위로 갈수록 +)
* **배열:** `map[row][col]`  세로 `row`, 가로 `col` (아래로 갈수록 +)

> **💡 노하우:**
> 문제에서 $(x, y)$를 주면, 코드에서는 항상 **`map[y][x]`** 형태로 사용하는 것으로 통일하세요.
> (즉, 좌표를 행(세로)으로, 좌표를 열(가로)로 사용)

**"엑셀(Excel)"**이나 **"아파트 우편함"**을 떠올리면 가장 이해하기 쉽습니다. 그림과 함께 아주 직관적으로 설명해 드릴게요.

#### 1. 핵심 이미지: 컴퓨터의 좌표는 "책 읽는 순서"와 같다

우리가 책을 읽을 때 **왼쪽 위**에서 시작해서 아래로 내려가죠? 2차원 배열도 똑같습니다.

* **시작점(0, 0):** 맨 **왼쪽 위** 구석입니다.
* **Row (행):** 몇 번째 **"줄(Line)"**이냐를 따집니다. 줄이 바뀔수록 **아래로** 내려갑니다.
* **Col (열):** 한 줄 안에서 몇 번째 **"칸"**이냐를 따집니다. 칸이 넘어갈수록 **오른쪽으로** 갑니다.

위 이미지를 보면서 아래 설명을 매칭해 보세요.

---

#### 2. `map[row][col]` 해부하기

`map[row][col]`을 아파트 호수에 비유해 보겠습니다.

##### ① `row` (행)  "몇 층(세로 위치)" 인가?

* 배열 선언: `int[][] map`은 **[가로줄]**들을 세로로 쌓아놓은 것입니다.
* `map[0]`: 0번째 줄 (맨 윗줄)
* `map[1]`: 1번째 줄 (그 아랫줄)
* 숫자가 커질수록 **아래로() 내려갑니다.**
* 그래서 `row` 인덱스는 **세로 위치(Y축)**를 결정합니다.

##### ② `col` (열)  "몇 호(가로 위치)" 인가?

* 그 줄(Row) 안에서 몇 번째 칸인지 찾습니다.
* `map[0][0]`: 0번째 줄의 0번째 칸 (맨 왼쪽)
* `map[0][1]`: 0번째 줄의 1번째 칸 (오른쪽으로 한 칸 이동)
* 숫자가 커질수록 **오른쪽()으로 갑니다.**
* 그래서 `col` 인덱스는 **가로 위치(X축)**를 결정합니다.

---

#### 3. 수학 그래프 vs 프로그래밍 배열 비교

가장 헷갈리는 이유가 바로 **Y축(세로)의 방향** 때문입니다.

| 비교 | 수학 좌표계 () | 프로그래밍 2차원 배열 (`map[row][col]`) |
| --- | --- | --- |
| **기준점 (0,0)** | **왼쪽 아래** (Bottom-Left) | **왼쪽 위** (Top-Left) |
| **X축 (가로)** | 오른쪽으로 갈수록 커짐 (+) | `col` : 오른쪽으로 갈수록 커짐 (+) (동일) |
| **Y축 (세로)** | **위로** 갈수록 커짐 (+) | **아래로** 갈수록 커짐 (+) (**반대!**) |
| **표기법** |  | `map[y][x]` (순서 주의!) |

> **💡 중요 팁:**
> 코딩할 때는 수학시간의 축을 뒤집어서 **"중력 방향(아래)"**으로 숫자가 커진다고 생각하세요!

#### 4. 실제 코드로 확인하기

```java
// map[세로위치][가로위치]
// map[y][x]

int[][] map = {
    {1, 2, 3}, // map[0] -> 0번 줄 (맨 위)
    {4, 5, 6}, // map[1] -> 1번 줄 (중간) - 아래로 내려옴 (+)
    {7, 8, 9}  // map[2] -> 2번 줄 (맨 아래) - 더 아래로 내려옴 (+)
};

// 숫자 6을 가져오려면?
// 1. 세로(줄) 찾기: 두 번째 줄이니까 인덱스 1 -> map[1]
// 2. 가로(칸) 찾기: 세 번째 칸이니까 인덱스 2 -> map[1][2]

```

**요약하자면:**

* `row`는 **몇 번째 줄**인지를 뜻하므로, 숫자가 커지면 **아래로** 내려갑니다. (세로 좌표)
* `col`은 **몇 번째 칸**인지를 뜻하므로, 숫자가 커지면 **오른쪽으로** 갑니다. (가로 좌표)


### ② 해상도 2배 (Resolution Scaling)

경로가 겹치는지, 혹은 점과 점 사이를 통과해서는 안 되는지 판단이 모호할 때 사용합니다.

* **적용 대상:** 도형의 테두리 타기, 미세한 경로 분리 문제.
* **방법:** 맵 크기와 모든 좌표 입력을  하고, 결과값은  한다.

### ③ 오프셋 (Offset) 더하기

좌표가 음수(`-50 ~ 50`)로 주어지면 배열 인덱스로 사용할 수 없습니다.

* **방법:** 모든 좌표에 일정 값(예: `+50`)을 더해 **0 이상의 양수**로 변환합니다.
* 예: `map[x + 50][y + 50] = 1;`

### ④ 패딩 (Padding) 주기

배열 경계 검사(`if nx < 0 ...`)는 귀찮고 실수하기 쉽습니다.

* **방법:** 맵을 딱 맞게(`50x50`) 만들지 말고, 넉넉하게 **`55x55`** 또는 **`105x105`** 로 선언하세요.
* 인덱스가 살짝 튀어도 에러가 나지 않고, 기본값 `0` 덕분에 자연스럽게 `continue` 됩니다.

### ⑤ 시뮬레이션 vs 수학적 계산

문제를 보자마자 결정해야 하는 사항입니다.

* **좌표 범위가 작다 (N  200~500):**
* **시뮬레이션 (배열+BFS)**: 무조건 2차원 배열을 만들고 직접 그리세요. 머리보다 컴퓨터가 정확합니다.


* **좌표 범위가 매우 크다 (N  1억):**
* **수학/공식**: 배열 생성이 불가능합니다. 직사각형 겹침 공식이나 좌표 압축 등의 알고리즘을 써야 합니다.