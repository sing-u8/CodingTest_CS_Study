## 질문
이 해답에서는 그걸 적용 안했는데?

이거는 굳이 그렇게 안해도 되서 그런거야?

그리고 map[y][x] 형태를 적용해도 풀이에는 문제가 없는거야?

## 답변
네, **정말 정확하게 보셨습니다.** 날카로운 지적입니다!

제가 앞서 설명해 드린 **"노하우(map[y][x] 사용)"**는 **실수를 줄이고 디버깅을 편하게 하기 위한 '권장 사항'**이지, 절대 어겨서는 안 되는 **'강제 규칙'**은 아닙니다.

질문하신 내용에 대해 시원하게 답변해 드리겠습니다.

---

### 1. 왜 이 코드는 `map[x][y]`를 썼을까?

이 풀이 작성자는 **"직관성"**을 선택한 것입니다.

* 문제에서 좌표를 $(x, y)$로 줍니다.
* 그러니 코드를 짤 때도 고민 없이 `map[x][y]`로 적는 것이 **입력 순서와 똑같아서** 편하다고 느낀 것이죠.
* **단점:** 만약 이 `map`을 `System.out.println`으로 출력해본다면, 행과 열이 뒤바뀌어(Transpose) 보여서 눈으로 확인하기가 매우 어지러울 것입니다.
* **장점:** 코드를 짤 때 머릿속으로 "x는 x끼리, y는 y끼리" 매칭하기가 쉽습니다.

### 2. `map[x][y]`로 해도 문제가 없는 이유 (가장 중요!)

**"일관성(Consistency)"만 지키면 정답은 똑같습니다.**

지도를 가로로 보든, 세로로 보든, 혹은 90도 돌려서 보든 **"길이 연결되어 있다"는 사실은 변하지 않기 때문**입니다.

* **방식 A (추천):** `map[y][x]`에 저장하고  `map[y][x]`에서 꺼낸다.
* **방식 B (이 코드):** `map[x][y]`에 저장하고  `map[x][y]`에서 꺼낸다.

이 코드에서는 저장할 때 `map[x][y]`로 저장했고, 읽을 때도 `map[nx][ny]` (즉, x를 앞 인덱스에) 사용했으므로 논리적으로 완벽하게 작동합니다.

---

### 3. 만약 `map[y][x]` 형태로 바꾸고 싶다면?

`map[y][x]` (행=y, 열=x) 형태로 풀어도 **당연히 풀이에 전혀 문제가 없습니다.** 오히려 디버깅할 때는 이쪽이 훨씬 편합니다.

코드를 `map[y][x]` 스타일로 바꾼다면 아래 두 부분만 수정하면 됩니다.

#### 수정 전 (현재 코드 - x가 행, y가 열)

```java
// 저장할 때
map[x][y] = 1; 

// 이동할 때 (dx가 앞 인덱스인 x를 변화시킴)
int nx = cx + dx[i]; 
int ny = cy + dy[i];
if (map[nx][ny] == 1) ...

```

#### 수정 후 (추천 방식 - y가 행, x가 열)

```java
// 저장할 때 (순서 반대!)
map[y][x] = 1; 

// 이동할 때 (순서 반대!)
// map[행][열] 이므로 map[ny][nx] 로 접근해야 함
int nx = cx + dx[i];
int ny = cy + dy[i];

// ★ 접근할 때 y를 먼저 씀
if (map[ny][nx] == 1) ... 

```

---

### 4. 요약 및 결론

1. **해답 코드가 틀린 건가요?**
* 아닙니다. **맞습니다.** 단지 `x`를 배열의 첫 번째 인덱스(행)로 쓰기로 **스스로 규칙을 정하고 일관성 있게** 지켰을 뿐입니다.


2. **굳이 `map[y][x]`를 안 해도 되나요?**
* 네, 헷갈리지 않을 자신만 있다면 `map[x][y]`로 해도 무방합니다.
* 하지만 나중에 디버깅(출력)을 하거나, 2차원 배열의 관례(행, 열)를 따르는 다른 알고리즘과 섞어 쓸 때는 **`map[y][x]`가 훨씬 유리**합니다.


3. **결론:**
* 지금 보신 코드는 `map[x][y]` 방식을 썼지만, **작성자님은 `map[y][x]` 방식을 습관화하시는 것을 강력 추천**합니다. 실무나 복잡한 구현 문제에서는 `[행][열]` 관념을 지키는 게 실수를 훨씬 줄여줍니다.



궁금증이 해결되셨나요? 결국 **"내가 정한 기준을 끝까지 지키느냐"**가 핵심입니다!